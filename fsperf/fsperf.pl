#!/usr/bin/perl
#
# For test:
# 	perf script -s fsperf.pl -i perf-block.data
# 	perf script -s fsperf.pl -i perf-sched.data
#

if ($ENV{'PERF_EXEC_PATH'}) {
    no warnings;
    use lib "$ENV{'PERF_EXEC_PATH'}/scripts/perl/Perf-Trace-Util/lib";
    use lib "./Perf-Trace-Util/lib";

    require Perf::Trace::Core;
    import Perf::Trace::Core;
    require Perf::Trace::Context;
    import Perf::Trace::Context;
    require Perf::Trace::Util;
    import Perf::Trace::Util;
}

use strict;
use warnings;
use bignum;
use Getopt::Long;
use Cwd;

my (%stats, %switch_state);

my $perf_sched_data = "perf-sched.data";
my $perf_block_data = "perf-block.data";
my $output_dir = "fsperf-output";

# less than this seek distance will be ignore
my $seek_threshold = 0;
# 0: absolute distance, 1: relative distance
my $seek_relative = 0;

my @target_pid = ();
my ($cur_time, $perf_start, $perf_end, $perf_xstart, $perf_xend);

##################################
#
# Utility functions
#

use constant MINORBITS => 20;
use constant MINORMASK => ((1 << MINORBITS) - 1);

sub kmajor($)
{
    my $dev = shift;
    return $dev >> MINORBITS;
}

sub kminor($)
{
    my $dev = shift;
    return $dev & MINORMASK;
}

sub kmakedev($$)
{
    my $major = shift;
    my $minor = shift;
    return $major << MINORBITS | $minor;
}

sub kdevname($)
{
    my $dev = shift;
    return sprintf("%u,%u", kmajor($dev), kminor($dev))
}

sub min($$)
{
    my $a = shift;
    my $b = shift;
    return $a if (!defined($b));
    return $b if (!defined($a));
    return $b if ($a > $b);
    return $a;
}

sub max($$)
{
    my $a = shift;
    my $b = shift;
    return $a if (!defined($b));
    return $b if (!defined($a));
    return $b if ($a < $b);
    return $a;
}

use constant NSEC_PER_SEC => 1000000000;

sub to_tv64($$)
{
    my ($secs, $nsecs) = @_;
    return $secs * NSEC_PER_SEC + $nsecs;
}

sub to_sec($)
{
    my $tv64 = shift;
    return int($tv64 / NSEC_PER_SEC);
}

sub to_nsec($)
{
    my $tv64 = shift;
    return int($tv64 % NSEC_PER_SEC);
}

sub to_sec_nsec($)
{
    my $tv64 = shift;
    return to_sec($tv64) + to_nsec($tv64) / NSEC_PER_SEC;
}

sub time_str($$)
{
    my ($secs, $nsecs) = @_;
    return sprintf("%u.%09u", $secs, $nsecs);
}

sub tv64_str($)
{
    my $tv64 = shift;
    return time_str(to_sec($tv64), to_nsec($tv64));
}

sub pr_warn(@)
{
    warn "Warning: @_\n";
}

sub safe_system
{
    print STDERR "Run command: @_\n";
    system(@_) == 0 or die "Exited abnormally with code $?: `@_'";
}

# perf script event handlers, generated by perf script -g perl
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Perl functions of the form common_*($context).
# See Context.pm for the list of available functions.

sub update_cur_time($$)
{
    my ($secs, $nsecs) = @_;
    my $time = to_tv64($secs, $nsecs);

    $cur_time = $secs;
    $perf_start = min($perf_start, $time);
    $perf_end = max($perf_end, $time);
}

sub calc_start_end_time
{
    # Adjust range of start and end
    $perf_xstart = to_sec($perf_start) - 1;
    $perf_xend = to_sec($perf_end) + 2;
}

sub create_file($$;$)
{
    my $name = shift;
    my $mode = shift;
    my $curdir = shift;
    my $path;

    if ($curdir) {
	$path = $name;
    } else {
	if (! -d $output_dir) {
	    mkdir($output_dir);
	}
	$path = "$output_dir/$name";
    }

    my $fh;
    open($fh, "> $path") or die "Couldn't create file: $path: $!";
    chmod($mode, $fh);

    return $fh;
}

sub create_datfile($)
{
    my $base = shift;

    my $name = sprintf("%s.dat", $base);
    return create_file($name, 0644);
}

##################################
#
# plot
#

# Using linetype color for state
my $R_COLOR	= 20;	# TASK_RUNNING color
my $W_COLOR	= 21;	# cpu wait color
my $S_COLOR	= 22;	# TASK_INTERRUPTIBLE color
my $D_COLOR	= 23;	# TASK_UNINTERRUPTIBLE color

my $plot_missing_char = "-";

sub fname_plot_color()
{
    return ".color.gp";
}

sub output_plot_color($)
{
    my $fname = shift;

    # If not exists, write color script
    if (-f "$output_dir/$fname") {
	return;
    }

    my $fh = create_file($fname, 0644);

    print $fh <<"EOF";
if ((GPVAL_VERSION < 4.5) || \\
   (!strstrt(GPVAL_COMPILE_OPTIONS,"+USER_LINETYPES"))) \\
   exit

set linetype 1 linecolor rgb \"royalblue\"
set linetype 2 linecolor rgb \"forest-green\"
set linetype 3 linecolor rgb \"dark-turquoise\"
set linetype 4 linecolor rgb \"dark-pink\"
set linetype 5 linecolor rgb \"dark-salmon\"
set linetype 6 linecolor rgb \"dark-violet\"
set linetype 7 linecolor rgb \"blue\"
set linetype 8 linecolor rgb \"green\"
set linetype 9 linecolor rgb \"red\"

set linetype ${R_COLOR} linecolor rgb \"forest-green\"
set linetype ${W_COLOR} linecolor rgb \"red\"
set linetype ${S_COLOR} linecolor rgb \"dark-gray\"
set linetype ${D_COLOR} linecolor rgb \"skyblue\"
EOF

    close($fh);
}

sub output_plot_pre($$$$@)
{
    my $fh = shift;
    my $title = shift;
    my $xlabel = shift;
    my $ylabel = shift;
    my @configs = @_;

    my $fname_color = fname_plot_color();
    output_plot_color($fname_color);

    print $fh <<"EOF";
#!/usr/bin/gnuplot

#set term dumb
#set term svg
#set term png truecolor
#set output 'example.svg'

unset format
load "${fname_color}"

set title '${title}'
set xrange [${perf_xstart}:${perf_xend}]
set xlabel '${xlabel}'
set ylabel '${ylabel}'
set grid
EOF
    foreach my $conf (@configs) {
	print $fh "$conf\n";
    }

    print $fh <<"EOF";

plot \\
EOF
}

sub output_plot_post($)
{
    my $fh = shift;

    print $fh <<"EOF";

pause -1 "Hit return to continue"
EOF
}

sub output_plot_summary($$)
{
    my $dev = shift;
    my $need_sched = shift;

    my $devname = kdevname($dev);
    my $fname = sprintf("%s_summary.gp", $devname);

    my $fh = create_file($fname, 0755);

    my @plot_gp = (
		   fname_plot_bno($dev),
		   fname_plot_mbps($dev),
		   fname_plot_iops($dev),
		   fname_plot_qdepth($dev),
		   fname_plot_lat_q2c($dev, "c"),
		   fname_plot_lat_d2c($dev, "c"),
		   fname_plot_seek_nr($dev, "c"),
		   fname_plot_seek_step($dev, "c")
		  );
    # Add schedule plot if need
    if ($need_sched and scalar(@target_pid)) {
	my @sched_gp = map { fname_plot_sched($_); } @target_pid;
	push(@plot_gp, @sched_gp);
    }

    my $nr_plots = scalar(@plot_gp);
    my $height = 300 * $nr_plots;
    my $width = 600;

    print $fh <<"EOF";
#!/usr/bin/gnuplot

set term png truecolor size ${width}, ${height}
set output '${devname}_summary.png'
set lmargin 15
set multiplot layout ${nr_plots},1 columnsfirst scale 1.0,0.9 offset 0.0,0.0

EOF
    close($fh);

    my $oldpwd = getcwd();
    chdir($output_dir);

    my $cmd = "cat " . join(" ", @plot_gp) . " | grep -v ^pause >> $fname";
    safe_system($cmd);

    # Run summary.gp
    $cmd = "./$fname > /dev/null 2>&1";
    safe_system($cmd);

    chdir($oldpwd);

    # Move .png to current dir
    $cmd = "mv $output_dir/*.png .";
    safe_system($cmd);
}

##################################
#
# block events
#

my %EVENT_LONGNAME = (
		      "block::block_bio_queue"		=> "Queue",
		      "block::block_bio_frontmerge"	=> "FrontMerge",
		      "block::block_bio_backmerge"	=> "BackMerge",
		      "block::block_rq_issue"		=> "Issue",
		      "block::block_rq_complete"	=> "Complete"
		     );
my %EVENT_SHORTNAME = (
		       "block::block_bio_queue"		=> "Q",
		       "block::block_bio_frontmerge"	=> "F",
		       "block::block_bio_backmerge"	=> "M",
		       "block::block_rq_issue"		=> "D",
		       "block::block_rq_complete"	=> "C"
		      );
my %DIR_LONGNAME = (
		    "r" => "Read",
		    "w" => "Write",
		    "c" => "Combined"
		   );

sub make_io_str($$$$)
{
    my ($tv64, $dir, $sector, $nr_sector) = @_;
    my $time_str = tv64_str($tv64);
    return "$time_str, $dir, $sector + $nr_sector";
}

sub get_dir(@)
{
    my ($event_name, $context, $common_cpu, $common_secs,
	$common_nsecs, $common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    my $dir;

    # Check direction
    if (index($rwbs, "R") >= 0) {
	$dir = "r";
    } elsif (index($rwbs, "W") >= 0) {
	$dir = "w";
    } else {
	my $devname = kdevname($dev);
	my $tv64 = to_tv64($common_secs, $common_nsecs);

	pr_warn("Unknown direction: ($devname): ",
		make_io_str($tv64, $rwbs, $sector, $nr_sector));
    }

    return $dir;
}

sub fname_plot_bno($)
{
    my $dev = shift;
    return sprintf("%s_plot_bno.gp", kdevname($dev));
}

sub output_plot_bno($)
{
    my $dev = shift;
    my $fname = fname_plot_bno($dev);

    my $fh = create_file($fname, 0755);

    output_plot_pre($fh, "I/O Position",
		    "Time (secs)", "Disk offset (byte)",
		    "set format y '%.1s %cB'",
		    "set pointsize 0.5",
		    "set bars 0.0",
		    "",
		    "to_byte(blk) = (blk * 512)");

    my $first = 1;
    foreach my $dir ("r", "w") {
	foreach my $type ("Queue", "Issue", "Complete") {
	    my $datafile = sprintf("%s_bno_%s_%s.dat", kdevname($dev),
				   lc($type), $dir);

	    print $fh ", \\\n" if (not $first);
	    $first = 0;

	    # Set point at middle of range on a I/O request
#	    print $fh
#		"'$datafile' using 1:(to_byte(\$3 + \$2) / 2) title \"$DIR_LONGNAME{$dir} $type\" with points pointtype 7";
	    # Set a line of range on a I/O request
	    print $fh
		"'$datafile' using 1:(to_byte(\$2)):(to_byte(\$2)):(to_byte(\$3)) title \"$DIR_LONGNAME{$dir} $type\" with yerrorbars";
	}
    }
    print $fh "\n";

    output_plot_post($fh);

    close($fh);
}

sub fname_plot_mbps($)
{
    my $dev = shift;
    return sprintf("%s_plot_mbps.gp", kdevname($dev));
}

sub output_plot_mbps($)
{
    my $dev = shift;
    my $fname = fname_plot_mbps($dev);
    my $datafile = sprintf("%s_blkps_c.dat", kdevname($dev));

    my $fh = create_file($fname, 0755);

    output_plot_pre($fh, "Throughput",
		    "Time (secs)", "MB/s",
		    "set yrange [0:]",
		    "",
		    "to_mb(blk) = (blk * 512) / (1024 * 1024)");

    print $fh <<"EOF";
'$datafile' using 1:(to_mb(\$2)) title "I/O" with lines
EOF

    output_plot_post($fh);

    close($fh);
}

sub fname_plot_iops($)
{
    my $dev = shift;
    return sprintf("%s_plot_iops.gp", kdevname($dev));
}

sub output_plot_iops($)
{
    my $dev = shift;
    my $fname = fname_plot_iops($dev);
    my $datafile = sprintf("%s_iops_c.dat", kdevname($dev));

    my $fh = create_file($fname, 0755);

    output_plot_pre($fh, "IO/s",
		    "Time (secs)", "IO/s",
		    "set yrange [0:]");

    print $fh <<"EOF";
'$datafile' using 1:2 title "I/O" with lines
EOF

    output_plot_post($fh);

    close($fh);
}

sub fname_plot_qdepth($)
{
    my $dev = shift;
    return sprintf("%s_plot_qdepth_c.gp", kdevname($dev));
}

sub output_plot_qdepth($)
{
    my $dev = shift;
    my $fname = fname_plot_qdepth($dev);
    my $datafile = sprintf("%s_qdepth_c.dat", kdevname($dev));

    my $fh = create_file($fname, 0755);

    output_plot_pre($fh, "Queue Depth",
		    "Time (secs)", "Queue Depth (Number of BIOs)",
		    "set yrange [0:]");

    print $fh <<"EOF";
'$datafile' using 1:2 title \"Depth\" with lines
EOF

    output_plot_post($fh);

    close($fh);
}

sub fname_plot_lat_x2c($$$)
{
    my $event_name = shift;
    my $dev = shift;
    my $dir = shift;
    my $shortname = $EVENT_SHORTNAME{$event_name};
    return sprintf("%s_plot_lat_%s2c_%s.gp", kdevname($dev),
		   lc($shortname), $dir);
}

sub output_plot_lat_x2c($$$)
{
    my $event_name = shift;
    my $dev = shift;
    my $dir = shift;
    my $shortname = $EVENT_SHORTNAME{$event_name};
    my $fname = fname_plot_lat_x2c($event_name, $dev, $dir);
    my $datafile = sprintf("%s_lat_%s2c_%s.dat", kdevname($dev),
			   lc($shortname), $dir);

    my $fh = create_file($fname, 0755);

    my $title = sprintf("%s to Complete Latency time - (%s)",
			$EVENT_LONGNAME{$event_name} , $DIR_LONGNAME{$dir});
    my $label = sprintf("%s2C", $shortname);

    output_plot_pre($fh, $title,
		    "Time (secs)", "Latency time (secs)",
		    "set yrange [0:]");

    print $fh <<"EOF";
'$datafile' using 1:2 title \"${label}\" with impulses
EOF

    output_plot_post($fh);

    close($fh);
}

sub fname_plot_lat_q2c($$)
{
    my $dev = shift;
    my $dir = shift;
    return fname_plot_lat_x2c("block::block_bio_queue", $dev, $dir);
}

sub output_plot_lat_q2c($$)
{
    my $dev = shift;
    my $dir = shift;
    output_plot_lat_x2c("block::block_bio_queue", $dev, $dir);
}

sub fname_plot_lat_d2c($$)
{
    my $dev = shift;
    my $dir = shift;
    return fname_plot_lat_x2c("block::block_rq_issue", $dev, $dir);
}

sub output_plot_lat_d2c($$)
{
    my $dev = shift;
    my $dir = shift;
    output_plot_lat_x2c("block::block_rq_issue", $dev, $dir);
}

sub fname_plot_seek_nr($$)
{
    my $dev = shift;
    my $dir = shift;
    return sprintf("%s_plot_seek_nr_%s.gp", kdevname($dev), $dir);
}

sub output_plot_seek_nr($$)
{
    my $dev = shift;
    my $dir = shift;
    my $fname = fname_plot_seek_nr($dev, $dir);
    my $datafile = sprintf("%s_seek_nr_%s.dat", kdevname($dev), $dir);

    my $fh = create_file($fname, 0755);

    output_plot_pre($fh, "Number of Seeks - ($DIR_LONGNAME{$dir})",
		    "Time (secs)", "Number of Seeks",
		    "set yrange [0:]");

    print $fh <<"EOF";
'$datafile' using 1:2 title \"Seeks\" with lines
EOF

    output_plot_post($fh);

    close($fh);
}

sub fname_plot_seek_step($$)
{
    my $dev = shift;
    my $dir = shift;
    return sprintf("%s_plot_seek_step_%s.gp", kdevname($dev), $dir);
}

sub output_plot_seek_step($$)
{
    my $dev = shift;
    my $dir = shift;
    my $fname = fname_plot_seek_step($dev, $dir);
    my $datafile = sprintf("%s_seek_step_%s.dat", kdevname($dev), $dir);

    my $fh = create_file($fname, 0755);

    output_plot_pre($fh, "Seek Steps - ($DIR_LONGNAME{$dir})",
		    "Time (secs)", "Disk offset (byte)",
		    "set format y '%.1s %cB'",
		    "set pointsize 0.5",
		    "",
		    "to_byte(blk) = (blk * 512)");

    print $fh <<"EOF";
'$datafile' using 1:(to_byte(\$2)) title \"D2D seek\" with linespoints
EOF

    output_plot_post($fh);

    close($fh);
}

sub create_dev_datfile($$)
{
    my $dev = shift;
    my $postfix = shift;

    my $base = sprintf("%s_%s", kdevname($dev), $postfix);
    return create_datfile($base);
}

# Output I/O position info
sub add_bno(@)
{
    my ($dir,
	$event_name, $context, $common_cpu, $common_secs,
	$common_nsecs, $common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    my $fname = sprintf("bno_%s_%s", lc($EVENT_LONGNAME{$event_name}), $dir);

    # Create file if need
    if (!defined($stats{$dev}{$fname})) {
	$stats{$dev}{$fname} = create_dev_datfile($dev, $fname);
    }

    # Output I/O position per read or write
    my $fh = $stats{$dev}{$fname};
    print $fh time_str($common_secs, $common_nsecs), " $sector ",
	$sector + $nr_sector, "\n";
}

# Collect completed blocks and IO/s
sub add_io(@)
{
    my ($dir,
	$event_name, $context, $common_cpu, $common_secs,
	$common_nsecs, $common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    $stats{$dev}{"complete_blocks"}[$cur_time] += $nr_sector;
    $stats{$dev}{"complete_io"}[$cur_time]++;

    $stats{$dev}{"req_blocks"} += $nr_sector;
    $stats{$dev}{"req_nr"}++;
    # Remember maximum sectors on single request
    $stats{$dev}{"req_max"} = max($stats{$dev}{"req_max"}, $nr_sector);
    # Remember minimum sectors on single request
    $stats{$dev}{"req_min"} = min($stats{$dev}{"req_min"}, $nr_sector);
}

# Update queue depth
sub update_qdepth($$$)
{
    my $dev = shift;
    my $time = shift;
    my $num = shift;

    # Modify queue depth
    $stats{$dev}{"qdepth"} += $num;
    $stats{$dev}{"qdepth_max"} =
	max($stats{$dev}{"qdepth_max"}, $stats{$dev}{"qdepth"});

    my $fname = "qdepth_c";
    # Create file if need
    if (!defined($stats{$dev}{$fname})) {
	$stats{$dev}{$fname} = create_dev_datfile($dev, $fname);
    }

    my $fh = $stats{$dev}{$fname};
    my $time_str = tv64_str($time);
    print $fh  "$time_str " . $stats{$dev}{"qdepth"} . "\n";
}

# Collect Queue(Q) pending I/O
sub add_queue_pending(@)
{
    my ($dir,
	$event_name, $context, $common_cpu, $common_secs,
	$common_nsecs, $common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    my $time = to_tv64($common_secs, $common_nsecs);

    # Save pending I/O
    $stats{$dev}{"pending"}{$sector}{"Q"} = $time;
    $stats{$dev}{"pending"}{$sector}{"nr"} = $nr_sector;

    # Update queue depth
    update_qdepth($dev, $time, 1);
}

# Update Queue pending I/O for merge
sub update_pending($$$$)
{
    my $dev = shift;
    my $old_sector = shift;
    my $sector = shift;
    my $nr_sector = shift;

    my $q_time = $stats{$dev}{"pending"}{$old_sector}{"Q"};
    my $d_time = $stats{$dev}{"pending"}{$old_sector}{"D"};
    delete($stats{$dev}{"pending"}{$old_sector});

    # Update pending I/O
    $stats{$dev}{"pending"}{$sector}{"Q"} = $q_time;
    $stats{$dev}{"pending"}{$sector}{"D"} = $d_time;
    $stats{$dev}{"pending"}{$sector}{"nr"} = $nr_sector;
}

# Collect info of FrontMerge pending I/O
sub add_frontmerge_pending(@)
{
    my ($dir,
	$event_name, $context, $common_cpu, $common_secs,
	$common_nsecs, $common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    my $time = to_tv64($common_secs, $common_nsecs);
    my $sector_end = $sector + $nr_sector;

    foreach my $s (keys($stats{$dev}{"pending"})) {
	if ($sector_end == $s) {
	    my $nr = $stats{$dev}{"pending"}{$s}{"nr"};

	    # Remove old pending I/O
	    delete($stats{$dev}{"pending"}{$sector});

	    # Front merge
	    $nr_sector += $nr;

	    update_pending($dev, $s, $sector, $nr_sector);
	    # Update queue depth
	    update_qdepth($dev, $time, -1);
	    return;
	}
    }

    my $devname = kdevname($dev);
    die "Couldn't find FrontMerge: ($devname): ",
	make_io_str($time, $dir, $sector, $nr_sector), "\n";
}

# Collect info of merge pending I/O
sub add_backmerge_pending(@)
{
    my ($dir,
	$event_name, $context, $common_cpu, $common_secs,
	$common_nsecs, $common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    my $time = to_tv64($common_secs, $common_nsecs);

    foreach my $s (keys($stats{$dev}{"pending"})) {
	my $nr = $stats{$dev}{"pending"}{$s}{"nr"};

	if ($s + $nr == $sector) {
	    # Remove old pending I/O
	    delete($stats{$dev}{"pending"}{$sector});

	    # Back merge
	    $nr += $nr_sector;

	    update_pending($dev, $s, $s, $nr);
	    # Update queue depth
	    update_qdepth($dev, $time, -1);
	    return;
	}
    }

    my $devname = kdevname($dev);
    die "Couldn't find BackMerge: ($devname): ",
	make_io_str($time, $dir, $sector, $nr_sector), "\n";
}

# Collect Issue(D) pending I/O
sub add_issue_pending(@)
{
    my ($dir,
	$event_name, $context, $common_cpu, $common_secs,
	$common_nsecs, $common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    my $time = to_tv64($common_secs, $common_nsecs);

    # Save pending I/O
    $stats{$dev}{"pending"}{$sector}{"D"} = $time;
}

# Complete(C) pending I/O
sub add_complete_pending(@)
{
    my ($dir,
	$event_name, $context, $common_cpu, $common_secs,
	$common_nsecs, $common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    my $time = to_tv64($common_secs, $common_nsecs);

    if (!defined($stats{$dev}{"pending"}{$sector})) {
	my $devname = kdevname($dev);
	pr_warn("$event_name: Missing queue event: ($devname): ",
		make_io_str($time, $dir, $sector, $nr_sector));
	return;
    }

    # Find completed pending I/O (pending I/O may be merged)
    my ($q_time, $d_time);
    while ($stats{$dev}{"pending"}{$sector} and $nr_sector) {
	my $nr = $stats{$dev}{"pending"}{$sector}{"nr"};
	if ($nr <= $nr_sector) {
	    $q_time = min($q_time, $stats{$dev}{"pending"}{$sector}{"Q"});
	    $d_time = min($d_time, $stats{$dev}{"pending"}{$sector}{"D"});
	    delete($stats{$dev}{"pending"}{$sector});

	    # Update queue depth
	    update_qdepth($dev, $time, -1);

	    $sector += $nr;
	    $nr_sector -= $nr;
	} else {
	    # partial complete
	    $nr -= $nr_sector;
	    $nr_sector = 0;
	    update_pending($dev, $sector, $sector + $nr_sector, $nr);
	}
    }
    if (!defined($q_time) or !defined($d_time)) {
	my $devname = kdevname($dev);
	die "$event_name: Found bogus I/O completion: ($devname): ",
	    make_io_str($time, $dir, $sector, $nr_sector), "\n";
    }
    my $lat_q2c = $time - $q_time;
    my $lat_d2c = $time - $d_time;

    # Remember stats of I/O latency
    foreach my $d ($dir, "c") {
	$stats{$dev}{"lat_q2c_total_$d"} += $lat_q2c;
	$stats{$dev}{"lat_q2c_max_$d"} =
	    max($stats{$dev}{"lat_q2c_max_$d"}, $lat_q2c);
	$stats{$dev}{"lat_q2c_min_$d"} =
	    min($stats{$dev}{"lat_q2c_min_$d"}, $lat_q2c);
	$stats{$dev}{"lat_q2c_nr_$d"}++;

	$stats{$dev}{"lat_d2c_total_$d"} += $lat_d2c;
	$stats{$dev}{"lat_d2c_nr_$d"}++;
	$stats{$dev}{"lat_d2c_max_$d"} =
	    max($stats{$dev}{"lat_d2c_max_$d"}, $lat_d2c);
	$stats{$dev}{"lat_d2c_min_$d"} =
	    min($stats{$dev}{"lat_d2c_min_$d"}, $lat_d2c);
    }

    for my $d ($dir, "c") {
	my $fname_q2c = sprintf("lat_q2c_%s", $d);
	my $fname_d2c = sprintf("lat_d2c_%s", $d);

	# Create file if need
	if (!defined($stats{$dev}{$fname_q2c})) {
	    $stats{$dev}{$fname_q2c} = create_dev_datfile($dev, $fname_q2c);
	}
	if (!defined($stats{$dev}{$fname_d2c})) {
	    $stats{$dev}{$fname_d2c} = create_dev_datfile($dev, $fname_d2c);
	}

	my $time_str = tv64_str($time);
	# Output Q2C latency time
	my $fh_q2c = $stats{$dev}{$fname_q2c};
	my $lat_q2c_str = tv64_str($lat_q2c);
	print $fh_q2c "$time_str $lat_q2c_str\n";
	# Output D2C latency time
	my $fh_d2c = $stats{$dev}{$fname_d2c};
	my $lat_d2c_str = tv64_str($lat_d2c);
	print $fh_d2c "$time_str $lat_d2c_str\n";
    }
}

sub seek_distance($$$$)
{
    my ($start, $end, $last_start, $last_end) = @_;

    if (!$seek_relative) {
	# Absolute seek
	return abs($last_end - $start);
    }

    # Relative seek
    die "unimplemented yet";
    return 0;
}

sub add_seek_distance($$$$$)
{
    my ($dir, $dev, $time, $start, $end) = @_;
    my $distance = 0;

    # Ignore first seek
    if (defined($stats{$dev}{"last_end_$dir"})) {
	$distance = seek_distance($start, $end,
				  $stats{$dev}{"last_start_$dir"},
				  $stats{$dev}{"last_end_$dir"});
	if ($distance > $seek_threshold) {
	    $stats{$dev}{"seek_nr_$dir"}[$cur_time]++;
	    $stats{$dev}{"seek_distance_$dir"}[$cur_time] += $distance;
	} else {
	    $distance = 0;
	}
    }
    # Update last location
    $stats{$dev}{"last_time_$dir"} = $time;
    $stats{$dev}{"last_start_$dir"} = $start;
    $stats{$dev}{"last_end_$dir"} = $end;

    return $distance;
}

# Collect issued block
sub add_seek(@)
{
    my ($dir,
	$event_name, $context, $common_cpu, $common_secs,
	$common_nsecs, $common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    my $time = to_tv64($common_secs, $common_nsecs);
    my $distance;

    foreach my $d ($dir, "c") {
	my $fname = sprintf("seek_step_%s", $d);
	my $last_time = $stats{$dev}{"last_time_$d"} || 0;
	my $last_end = $stats{$dev}{"last_end_$d"} || 0;

	# Add seek distance
	$distance = add_seek_distance($d, $dev, $time,
				      $sector, $sector + $nr_sector);
	# Create file if need
	if (!defined($stats{$dev}{$fname})) {
	    $stats{$dev}{$fname} = create_dev_datfile($dev, $fname);
	}
	# Output seek step
	my $fh = $stats{$dev}{$fname};
	my $end = $sector + $nr_sector;
#	print $fh "#$time $sector $end\n";
	if ($distance) {
	    my $last_time_str = tv64_str($last_time);
	    my $time_str = tv64_str($time);
	    print $fh "\n";
	    print $fh "$last_time_str $last_end\n";
	    print $fh "$time_str $sector\n";
	}
    }
}

sub block_main
{
    my %result;

    my $log = create_file("fsperf-block.log", 0644, 1);

    calc_start_end_time();

    # Output MB/s and IO/s
    foreach my $dev (keys %stats) {
	my $complete_blocks = $stats{$dev}{"complete_blocks"};
	my $complete_io = $stats{$dev}{"complete_io"};
	my $total_blk = 0;
	my $total_io = 0;

	my $fh_blk = create_dev_datfile($dev, "blkps_c");
	my $fh_io = create_dev_datfile($dev, "iops_c");
	for my $t (to_sec($perf_start)..to_sec($perf_end)) {
	    $total_blk += $complete_blocks->[$t];
	    print $fh_blk "$t.5 ", ($complete_blocks->[$t] || 0), "\n";

	    $total_io += ($complete_io->[$t] || 0);
	    print $fh_io "$t.5 ", ($complete_io->[$t] || 0), "\n";
	}
	close($fh_blk);
	close($fh_io);

	# Remember for short summary
	$result{$dev}{"total_blk"} = $total_blk;
	$result{$dev}{"total_io"} = $total_io;

	# Create plot script
	output_plot_bno($dev);
	output_plot_mbps($dev);
	output_plot_iops($dev);
    }

    # Summary Time
    print $log <<"EOF";
                      Time
----------------------------------------------------------
  Dev         Start(sec)           End(sec)        Elapse(sec)
EOF
    my $elapse = $perf_end - $perf_start;

    foreach my $dev (keys %stats) {
	printf $log " %4s    %15s    %15s    %15s\n",
	    kdevname($dev), tv64_str($perf_start), tv64_str($perf_end),
	    tv64_str($elapse);
    }

    # Summary IO
    print $log <<"EOF";

                      IO (Complete)
-----------------------------------------------------------------
  Dev        MB/s     Total(MB)         IO/s     Total(IO)
EOF
    foreach my $dev (keys %result) {
	my $total_mb = ($result{$dev}{"total_blk"} * 512) / (1024 * 1024);
	my $total_io = $result{$dev}{"total_io"};

	printf $log " %4s    %8.2f      %8.2f     %8.2f      %8u\n",
	    kdevname($dev), $total_mb / to_sec_nsec($elapse),
	    $total_mb, $total_io / to_sec_nsec($elapse),
	    $total_io;
    }

    # Summary Request size
    print $log <<"EOF";

                    Request size (Complete)
-----------------------------------------------------------------
  Dev       Avg       Min       Max    (1 == 512 bytes)
EOF
    foreach my $dev (keys %stats) {
	# Output short summary
	my $avg = $stats{$dev}{"req_blocks"} / $stats{$dev}{"req_nr"};
	printf $log " %4s  %8.2f  %8u  %8u\n",
	    kdevname($dev), $avg, $stats{$dev}{"req_min"},
	    $stats{$dev}{"req_max"};
    }

    # Summary Queue depth
    print $log <<"EOF";

                    Queue Depth
-----------------------------------------------------------------
  Dev      Max
EOF
    foreach my $dev (keys %stats) {
	# Output short summary
	my $max = $stats{$dev}{"qdepth_max"} || 0;

	printf $log " %4s     %4u\n",
	    kdevname($dev), $max;

	# Create plot script
	output_plot_qdepth($dev);
    }

    # Summary Q2C/D2C Latency
    print $log <<"EOF";

                    Latency time
-----------------------------------------------------------------
  Dev   Type  Direction          Avg          Min          Max    (secs)
EOF
    foreach my $dev (keys %stats) {
	foreach my $dir ("r", "w", "c") {
	    foreach my $type ("q2c", "d2c") {
		# Output short summary
		my $total = $stats{$dev}{"lat_${type}_total_${dir}"} || 0;
		my $nr = $stats{$dev}{"lat_${type}_nr_${dir}"} || 0;
		my $max = $stats{$dev}{"lat_${type}_max_${dir}"} || 0;
		my $min = $stats{$dev}{"lat_${type}_min_${dir}"} || 0;
		my $avg = $total / $nr;

		printf $log " %4s   %4s   %8s  %s  %s  %s\n",
		    kdevname($dev), uc($type), $DIR_LONGNAME{$dir},
		    tv64_str($avg), tv64_str($min), tv64_str($max);
	    }

	    # Create plot script
	    output_plot_lat_q2c($dev, $dir);
	    output_plot_lat_d2c($dev, $dir);
	}
    }

    # Output/Summary Seeks/s
    print $log <<"EOF";

                      Seeks/s (Issue)
-----------------------------------------------------------------
  Dev   Direction    Seeks/s  Total(Seeks)  Avg Distance(MB) Total Distance(MB)
EOF
    foreach my $dev (keys %stats) {
	foreach my $dir ("r", "w", "c") {
	    my $fname_nr = "seek_nr_$dir";
	    my $fname_distance = "seek_distance_$dir";
	    my $total_nr = 0;
	    my $total_distance = 0;

	    my $fh = create_dev_datfile($dev, $fname_nr);
	    for my $t (to_sec($perf_start)..to_sec($perf_end)) {
		my $nr = $stats{$dev}{$fname_nr}[$t] || 0;
		my $distance = $stats{$dev}{$fname_distance}[$t] || 0;
		$total_nr += $nr;
		$total_distance += $distance;
		print $fh "$t.5 ", $nr, "\n";
	    }
	    close($fh);

	    # Output short summary
	    my $avg_nr = $total_nr / to_sec_nsec($elapse);
	    my $avg_distance = $total_distance / $total_nr;
	    printf $log " %4s    %8s   %8.2f      %8.2f      %8.2f     %12.2f\n",
		kdevname($dev), $DIR_LONGNAME{$dir}, $avg_nr, $total_nr,
		($avg_distance * 512) / (1024 * 1024),
		($total_distance * 512) / (1024 * 1024);

	    # Create plot script
	    output_plot_seek_nr($dev, $dir);
	    output_plot_seek_step($dev, $dir);
	}
    }
    close($log);

    # Create summary plot
#    foreach my $dev (keys %stats) {
#	output_plot_summary($dev, 0);
#    }

    # Sanity check for pending I/O
    foreach my $dev (keys %stats) {
	my $devname = kdevname($dev);
	foreach my $s (keys($stats{$dev}{"pending"})) {
	    my $nr = $stats{$dev}{"pending"}{$s}{"nr"};
	    my $q_time = $stats{$dev}{"pending"}{$s}{"Q"} || 0;
	    my $d_time = $stats{$dev}{"pending"}{$s}{"D"} || 0;
	    my $d_str = tv64_str($d_time);

	    pr_warn("Missing Pending I/O: ($devname): ",
		    make_io_str($q_time, "", $s, $nr),
		    ", $d_str");
	}
    }

    # Remember $perf_xstart and $perf_xend
    $ENV{FSPERF_XSTART} = $perf_xstart;
    $ENV{FSPERF_XEND} = $perf_xend;
    $ENV{FSPERF_DEV} = join(",", keys(%stats));

    return 0;
}

#sub block::block_rq_remap
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$dev, $sector, $nr_sector, $old_dev, $old_sector, $rwbs) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub block::block_bio_remap
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$dev, $sector, $nr_sector, $old_dev, $old_sector, $rwbs) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub block::block_split
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$dev, $sector, $new_sector, $rwbs, $comm) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub block::block_unplug
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$nr_rq, $comm) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub block::block_plug
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$comm) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub block::block_sleeprq
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub block::block_getrq
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

sub block::block_bio_queue
{
    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
	$common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    update_cur_time($common_secs, $common_nsecs);

    # Flush request?
    if ($nr_sector == 0) {
	my $devname = kdevname($dev);
	my $tv64 = to_tv64($common_secs, $common_nsecs);

	pr_warn("$event_name: Ignore flush request: ($devname): ",
		make_io_str($tv64, $rwbs, $sector, $nr_sector));
	return;
    }

    my $dir = get_dir(@_);
    if ($dir) {
	add_bno($dir, @_);
	add_queue_pending($dir, @_);
    }
}

sub block::block_bio_frontmerge
{
    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
	$common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    update_cur_time($common_secs, $common_nsecs);

    my $dir = get_dir(@_);
    if ($dir) {
	add_frontmerge_pending($dir, @_);
    }
}

sub block::block_bio_backmerge
{
    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
	$common_pid, $common_comm,
	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;

    update_cur_time($common_secs, $common_nsecs);

    my $dir = get_dir(@_);
    if ($dir) {
	add_backmerge_pending($dir, @_);
    }
}

#sub block::block_bio_complete
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$dev, $sector, $nr_sector, $error, $rwbs) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub block::block_bio_bounce
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$dev, $sector, $nr_sector, $rwbs, $comm) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

sub block::block_rq_issue
{
    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
	$common_pid, $common_comm,
	$dev, $sector, $nr_sector, $bytes, $rwbs, $comm, $cmd) = @_;

    update_cur_time($common_secs, $common_nsecs);

    # Flush request?
    if ($nr_sector == 0) {
	my $devname = kdevname($dev);
	my $tv64 = to_tv64($common_secs, $common_nsecs);

	pr_warn("$event_name: Ignore flush request: ($devname): ",
		make_io_str($tv64, $rwbs, $sector, $nr_sector));
	return;
    }

    my @normalized_args = @_;
    splice(@normalized_args, 10, 1);

    my $dir = get_dir(@normalized_args);
    if ($dir) {
	add_bno($dir, @normalized_args);
	add_seek($dir, @normalized_args);
	add_issue_pending($dir, @normalized_args);
    }
}

#sub block::block_rq_insert
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$dev, $sector, $nr_sector, $bytes, $rwbs, $comm, $cmd) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

sub block::block_rq_complete
{
    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
	$common_pid, $common_comm,
	$dev, $sector, $nr_sector, $errors, $rwbs, $cmd) = @_;

    update_cur_time($common_secs, $common_nsecs);

    # Flush request?
    if ($nr_sector == 0) {
	my $devname = kdevname($dev);
	my $tv64 = to_tv64($common_secs, $common_nsecs);

	pr_warn("$event_name: Ignore flush request: ($devname): ",
		make_io_str($tv64, $rwbs, $sector, $nr_sector));
	return;
    }

    my @normalized_args = @_;
    splice(@normalized_args, 10, 1);

    my $dir = get_dir(@normalized_args);
    if ($dir) {
	add_bno($dir, @normalized_args);
	add_io($dir, @normalized_args);
	add_complete_pending($dir, @normalized_args);
    }
}

#sub block::block_rq_requeue
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$dev, $sector, $nr_sector, $errors, $rwbs, $cmd) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub block::block_rq_abort
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$dev, $sector, $nr_sector, $errors, $rwbs, $cmd) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

##################################
#
# sched events
#

use constant TASK_RUNNING		=> 0;
use constant TASK_INTERRUPTIBLE		=> 1;
use constant TASK_UNINTERRUPTIBLE	=> 2;
use constant TASK_STOPPED		=> 4;
use constant TASK_TRACED		=> 8;
use constant EXIT_ZOMBIE		=> 16;
use constant EXIT_DEAD			=> 32;
use constant TASK_DEAD			=> 64;
use constant TASK_WAKEKILL		=> 128;
use constant TASK_WAKING		=> 256;
use constant TASK_PARKED		=> 512;

sub fname_plot_sched($)
{
    my $pid = shift;
    return "sched_$pid.gp";
}

sub output_plot_sched($$)
{
    my $pid = shift;
    my $comm = shift;
    my $fname = fname_plot_sched($pid);
    my $datafile_time = "sched_${pid}_time.dat";
    my $datafile_stat = "sched_${pid}_stat.dat";

    my $fh = create_file($fname, 0755);

    my $ylow = -0.4;
    my $ylen = 0.025;
    my $ymin = $ylow - 0.1;
    my $ymax = 1.1;
    output_plot_pre($fh, "Task $pid ($comm) Schedule",
		    "Time (secs)", "Schedule Time (secs)",
		    "set yrange [$ymin:$ymax]",
		    "set ytics 0,0.1,1",
		    "set style fill transparent solid 0.75 noborder",
		    "set datafile missing '$plot_missing_char'",
		    "",
		    "ylow = $ylow",
		    "ylen = $ylen");

    # Line graph
    my @info_stat = (
		     { col => 2, name => "Running",	color => $R_COLOR },
		     { col => 3, name => "CPU wait",	color => $W_COLOR },
		     { col => 4, name => "Sleep",	color => $S_COLOR },
		     { col => 5, name => "Block",	color => $D_COLOR },
		    );
    my $need_comma = 0;
    foreach my $i (@info_stat) {
	my $col = $i->{col};
	my $name = $i->{name};
	my $color = $i->{color};

	print $fh ", \\\n" if ($need_comma);
	print $fh "'$datafile_stat' using 1:${col} title \"${name}\" with lines linetype ${color}";

	$need_comma = 1;
    }

    # Bars
    my @info_time = (
		     { col => 2, ypos => 10, color => $R_COLOR },
		     { col => 3, ypos =>  9, color => $W_COLOR },
		     { col => 4, ypos =>  8, color => $S_COLOR },
		     { col => 5, ypos =>  7, color => $D_COLOR },
		    );
    foreach my $i (@info_time) {
	my $col = $i->{col};
	my $ypos_l = $i->{ypos};
	my $ypos_h = $i->{ypos} + 1;
	my $color = $i->{color};

	# For bar each schedule type
	print $fh ", \\\n";
	print $fh
	    "'$datafile_time' using 1:(ylow):1:${col}:(ylow + ylen * ${ypos_l}):(ylow + ylen * ${ypos_h}) notitle with boxxyerrorbars linetype ${color}";
	# For bar of combined schedule type
	print $fh ", \\\n";
	print $fh
	    "'$datafile_time' using 1:(ylow):1:${col}:(ylow + ylen * 0):(ylow + ylen * 5) notitle with boxxyerrorbars linetype ${color}";
    }
    print $fh "\n";

    output_plot_post($fh);

    close($fh);
}

sub create_pid_datfile($$)
{
    my $pid = shift;
    my $postfix = shift;

    my $base = sprintf("sched_%u_%s", $pid, $postfix);
    return create_datfile($base);
}

sub is_interesting_pid($)
{
    my $pid = shift;

    if (!scalar(@target_pid) or grep { $_ == $pid } @target_pid) {
	return 1;
    }
    return 0;
}

sub sched_stat
{
    my $type = shift;
    my $pid = shift;
    my $comm = shift;
    my $time = shift;
    my $elapse = shift;

    if (!defined($stats{$pid}{fh})) {
	$stats{$pid}{fh} = create_pid_datfile($pid, "time");
    }

    my $fh = $stats{$pid}{fh};
    my $start = $time - $elapse;
    my $start_str = tv64_str($start);
    my $end = $time;
    my $end_str = tv64_str($end);

    # Output sched_*_type.dat
    my %end_pos = ( R => 1, W => 2, S => 3, D => 4 );
    my $idx = $end_pos{$type};
    my @cols = ($plot_missing_char, $plot_missing_char, $plot_missing_char,
		$plot_missing_char, $plot_missing_char);
    $cols[0] = $start_str;
    $cols[$idx] = $end_str;

    print $fh "@cols\n";

    # Remember stat
    $stats{$pid}{start} = min($stats{$pid}{start}, $start);
    $stats{$pid}{end} = max($stats{$pid}{end}, $end);
    $stats{$pid}{comm} = $comm;
    $stats{$pid}{$type}{total} += $elapse;
    # Add elapse to proper position
    my $cur_sec = to_sec($end);
    while ($elapse > 0) {
	my $cur_start = to_tv64($cur_sec, 0);
	my $cur_elapse = min($end - $cur_start, $elapse);

	$stats{$pid}{$type}{sec}[$cur_sec] += $cur_elapse;
	$elapse -= $cur_elapse;

	$end = $cur_start;
	$cur_sec--;
    }
}

#sub sched::sched_pi_setprio
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$comm, $pid, $oldprio, $newprio) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

sub sched::sched_stat_runtime
{
    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
	$common_pid, $common_comm,
	$comm, $pid, $runtime, $vruntime) = @_;

    update_cur_time($common_secs, $common_nsecs);

    if ($runtime and is_interesting_pid($pid)) {
	my $time = to_tv64($common_secs, $common_nsecs);
	sched_stat("R", $pid, $comm, $time, $runtime);
    }
}

sub sched::sched_stat_blocked
{
    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
	$common_pid, $common_comm,
	$comm, $pid, $delay) = @_;

    update_cur_time($common_secs, $common_nsecs);

    if ($delay and is_interesting_pid($pid)) {
	my $time = to_tv64($common_secs, $common_nsecs);
	sched_stat("D", $pid, $comm, $time, $delay);
    }
}

#sub sched::sched_stat_iowait
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$comm, $pid, $delay) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

sub sched::sched_stat_sleep
{
    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
	$common_pid, $common_comm,
	$comm, $pid, $delay) = @_;

    update_cur_time($common_secs, $common_nsecs);

    if ($delay and is_interesting_pid($pid)) {
	my $time = to_tv64($common_secs, $common_nsecs);
	sched_stat("S", $pid, $comm, $time, $delay);
    }
}

sub sched::sched_stat_wait
{
    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
	$common_pid, $common_comm,
	$comm, $pid, $delay) = @_;

    update_cur_time($common_secs, $common_nsecs);

    if ($delay and is_interesting_pid($pid)) {
	my $time = to_tv64($common_secs, $common_nsecs);
	sched_stat("W", $pid, $comm, $time, $delay);
    }
}

#sub sched::sched_process_exec
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$filename, $pid, $old_pid) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub sched::sched_process_fork
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$parent_comm, $parent_pid, $child_comm, $child_pid) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub sched::sched_process_wait
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$comm, $pid, $prio) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub sched::sched_wait_task
#{
#	my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	    $common_pid, $common_comm,
#	    $comm, $pid, $prio) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub sched::sched_process_exit
#{
#	my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	    $common_pid, $common_comm,
#	    $comm, $pid, $prio) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub sched::sched_process_free
#{
#	my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	    $common_pid, $common_comm,
#	    $comm, $pid, $prio) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub sched::sched_migrate_task
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$comm, $pid, $prio, $orig_cpu, $dest_cpu) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

sub remember_switch($$$$)
{
    my $type = shift;
    my $pid = shift;
    my $comm = shift;
    my $time = shift;

    $switch_state{$pid}{state} = $type;
    $switch_state{$pid}{comm} = $comm;
    $switch_state{$pid}{time} = $time;
}

sub sched::sched_switch
{
    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
	$common_pid, $common_comm,
	$prev_comm, $prev_pid, $prev_prio, $prev_state,
	$next_comm, $next_pid, $next_prio) = @_;

    update_cur_time($common_secs, $common_nsecs);

    if (is_interesting_pid($prev_pid)) {
	my $time = to_tv64($common_secs, $common_nsecs);
	if ($prev_state & TASK_RUNNING) {
	    remember_switch("R", $prev_pid, $prev_comm, $time);
	} elsif ($prev_state & TASK_INTERRUPTIBLE) {
	    remember_switch("S", $prev_pid, $prev_comm, $time);
	} elsif ($prev_state & TASK_UNINTERRUPTIBLE) {
	    remember_switch("D", $prev_pid, $prev_comm, $time);
	} else {
	    delete($switch_state{$prev_pid});
	}
    }
    if (is_interesting_pid($next_pid)) {
	my $time = to_tv64($common_secs, $common_nsecs);
	remember_switch("R", $next_pid, $next_comm, $time);
    }
}

#sub sched::sched_wakeup_new
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$comm, $pid, $prio, $success,
#	$target_cpu) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub sched::sched_wakeup
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$comm, $pid, $prio, $success,
#	$target_cpu) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub sched::sched_kthread_stop_ret
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$ret) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

#sub sched::sched_kthread_stop
#{
#    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
#	$common_pid, $common_comm,
#	$comm, $pid) = @_;
#
#    update_cur_time($common_secs, $common_nsecs);
#}

sub sched_main
{
    # Get $xstart and $xend
    $perf_xstart = $ENV{FSPERF_XSTART};
    $perf_xend = $ENV{FSPERF_XEND};

    # Add stat from last switch to now
    foreach my $pid (keys(%switch_state)) {
	my $type = $switch_state{$pid}{state};
	my $comm = $switch_state{$pid}{comm};
	my $time = $switch_state{$pid}{time};

	my $elapse = $perf_end - $time;
	sched_stat($type, $pid, $comm, $perf_end, $elapse);
    }

    # Output Scheduler stat
    my $log = create_file("fsperf-sched.log", 0644, 1);

    print $log <<"EOF";
                      Schedule Time
EOF
    foreach my $pid (sort { $a <=> $b } (keys(%stats))) {
	my $comm = $stats{$pid}{comm};
	my $start_time = $stats{$pid}{start};
	my $end_time = $stats{$pid}{end};
	my $elapse = $end_time - $start_time;
	my $run_time = $stats{$pid}{R}{total};
	my $wait_time = $stats{$pid}{W}{total};
	my $sleep_time = $stats{$pid}{S}{total};
	my $block_time = $stats{$pid}{D}{total};

	print $log <<"EOF";
----------------------------------------------------------
   Pid            comm       Start(sec)         End(sec)      Elapse(sec)
EOF
	printf $log "%6u %15s %16s %16s %16s\n",
	    $pid, $comm,
	    tv64_str($start_time), tv64_str($end_time), tv64_str($elapse);

	print $log <<"EOF";

                     Running(sec)                  CPU wait(sec)
EOF
	printf $log "       %16s (%6.2f%%)     %16s (%6.2f%%)\n",
	    tv64_str($run_time), ($run_time * 100) / $elapse,
	    tv64_str($wait_time), ($wait_time * 100) / $elapse;

	print $log <<"EOF";
                       Sleep(sec)                     Block(sec)
EOF
	printf $log "       %16s (%6.2f%%)     %16s (%6.2f%%)\n",
	    tv64_str($sleep_time), ($sleep_time * 100) / $elapse,
	    tv64_str($block_time), ($block_time * 100) / $elapse;

	my $fh = create_pid_datfile($pid, "stat");
	foreach my $idx (to_sec($start_time)..to_sec($end_time)) {
	    print $fh $idx + 0.5;
	    foreach my $type ("R", "W", "S", "D") {
		my $time_str = tv64_str($stats{$pid}{$type}{sec}[$idx] || 0);
		print $fh " $time_str";
	    }
	    print $fh "\n";
	}
	close($fh);

	# Create sched plot
	output_plot_sched($pid, $comm);
    }

    close($log);

    # Create summary plot
    foreach my $dev (split(/,/, $ENV{FSPERF_DEV})) {
	output_plot_summary($dev, 1);
    }
}

sub trace_unhandled
{
    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,
	$common_pid, $common_comm) = @_;

    update_cur_time($common_secs, $common_nsecs);
}

sub print_header
{
    my ($event_name, $cpu, $secs, $nsecs, $pid, $comm) = @_;

    printf("%-20s %5u %05u.%09u %8u %-20s ",
	   $event_name, $cpu, $secs, $nsecs, $pid, $comm);
}

# Packed byte string args of process_event():
#
# $event:	union perf_event	util/event.h
# $attr:	struct perf_event_attr	linux/perf_event.h
# $sample:	struct perf_sample	util/event.h
# $raw_data:	perf_sample->raw_data	util/event.h
#sub process_event
#{
#    my ($event, $attr, $sample, $raw_data) = @_;
#
#    my @event	= unpack("LSS", $event);
#    my @attr	= unpack("LLQQQQQLLQQ", $attr);
#    my @sample	= unpack("QLLQQQQQLL", $sample);
#    my @raw_data	= unpack("C*", $raw_data);
#
#    use Data::Dumper;
#    print Dumper \@event, \@attr, \@sample, \@raw_data;
#}

my %mode_table = (
		  FSPERF_MODE_REPORT	=> {
					    func => undef,
					    next => "FSPERF_MODE_BLOCK",
					    data => $perf_block_data,
					   },
		  FSPERF_MODE_BLOCK	=> {
					    func => \&block_main,
					    next => "FSPERF_MODE_SCHED",
					    data => $perf_sched_data,
					   },
		  FSPERF_MODE_SCHED	=> {
					    func => \&sched_main,
					    next => undef,
					    data => undef,
					   },
		 );

# Called from perf before starting events
sub trace_begin
{
    # Setup parameters from environment
    @target_pid = split(/,/, $ENV{FSPERF_TARGET_PID});
    $seek_threshold = $ENV{FSPERF_SEEK_THRESHOLD};
    $seek_relative = $ENV{FSPERF_SEEK_RELATIVE};
}

# Called from perf after all events was done
sub trace_end
{
    my $mode = $ENV{FSPERF_MODE};
    my $func = $mode_table{$mode}->{func};

    # Call post process function
    $func->();

    # Run next command
    run_next_cmd();
}

##################################
#
# State machine
#

sub run_perf_script($)
{
    my $data = shift;
    my $script = $ENV{FSPERF_SCRIPT};

    my $cmd = "perf script --hide-call-graph -s $script -i $data";

    safe_system($cmd);
}

sub run_next_cmd
{
    my $mode = $ENV{FSPERF_MODE};

    if ($mode_table{$mode}->{next}) {
	my $next = $mode_table{$mode}->{next};
	my $data = $mode_table{$mode}->{data};

	$ENV{FSPERF_MODE} = $next;
	run_perf_script($data);
    }
}

##################################
#
# Commands
#

sub record_help
{
    print <<"EOF";
Usage: $0 record <options> -- <cmdline>...

Options:
 <cmdline>...		 Any command you can specify in a shell.
 -d, --device=DEV        Record events only for DEV.
                         Accepts multiple times (e.g. -d /dev/sda -d /dev/sdb)
 -h, --help              This help.

EOF

    exit(1);
}

sub get_kdev($)
{
    my $path = shift;

    # FIXME: there is better portable way?
    open(my $lsblk, "lsblk -l -n -o MAJ:MIN $path |")
	or die "Couldn't run lsblk: $!";
    my $line = <$lsblk>;
    close($lsblk);

    if ($line and $line =~ m!\d+:\d+!) {
	my ($major, $minor) = split(/:/, $line);
	return kmakedev($major, $minor);
    }

    die "Invalid block device: $path\n";
}

# Make map for "partition => whole disk"
sub make_devmap
{
    my %devmap;

    # Find whole device from partition
    open(my $lsblk, "lsblk -l -n -o MAJ:MIN,TYPE |")
	or die "Couldn't run lsblk: $!";

    my $whole_disk;
    while (<$lsblk>) {
	my ($majmin, $type) = split(" ");
	my ($major, $minor) = split(":", $majmin);

	if ($type eq "disk" or $type eq "rom") {
	    $whole_disk = kmakedev($major, $minor);
	    $devmap{$whole_disk} = $whole_disk;
	} elsif ($whole_disk and $type eq "part") {
	    my $dev = kmakedev($major, $minor);
	    $devmap{$dev} = $whole_disk;
	} else {
	    die "Unknown state: " . kdevname($whole_disk) . " $type\n";
	}
    }

    close($lsblk);

    return %devmap;
}

sub make_filter_str(@)
{
    my @devices = @_;
    my %devmap = make_devmap();

    my $or_sep = "";
    my $filter;
    foreach my $path (@devices) {
	my $dev = get_kdev($path);

	if (!defined($devmap{$dev})) {
	    die "Coundn't find whole device for " . kdevname($dev);
	}
	my $whole_disk = $devmap{$dev};

	$filter .= $or_sep;
	$filter .= "dev==$whole_disk";

	$or_sep = "||";
    }

    return $filter;
}

sub run_record
{
    my $dev_filter = shift;

    my @block_events = (
#			"block:block_rq_remap",
#			"block:block_bio_remap",
#			"block:block_split",
#			"block:block_unplug",
#			"block:block_plug",
#			"block:block_sleeprq",
#			"block:block_getrq",
			"block:block_bio_queue",
			"block:block_bio_frontmerge",
			"block:block_bio_backmerge",
			"block:block_bio_complete",
			"block:block_rq_issue",
#			"block:block_rq_insert",
			"block:block_rq_complete",
#			"block:block_rq_requeue",
#			"block:block_rq_abort",
		       );
    my @sched_events = (
#			"sched:sched_pi_setprio",
			"sched:sched_stat_runtime",
			"sched:sched_stat_blocked",
#			"sched:sched_stat_iowait",
			"sched:sched_stat_sleep",
			"sched:sched_stat_wait",
			"sched:sched_process_exec",
			"sched:sched_process_fork",
#			"sched:sched_process_wait",
#			"sched:sched_wait_task",
			"sched:sched_process_exit",
#			"sched:sched_process_free",
			"sched:sched_switch",
#			"sched:sched_migrate_task",
#			"sched:sched_wakeup_new",
#			"sched:sched_wakeup",
#			"sched:sched_kthread_stop_ret",
#			"sched:sched_kthread_stop",
		       );

    #
    # Run perf record with following like options. Current perf
    # (3.8.x) can't specify "-g" option for each event.
    #
    # So, this separates perf by 2 commands. One is block events without "-g".
    # One is sched events with "-g".
    #
    #     perf record -a -c1 -o perf-block.data \
    #         -e 'block:*' --filter dev==0x800010 -- \
    #         perf record -a -c1 -g -o perf-sched.data -e 'sched:*' -- \
    #         dd if=/mnt/file of=/dev/null bs=4K

    # Make block events cmdline
    my @cmd = ("perf", "record", "-a", "-c1", "-o", $perf_block_data);
    foreach my $event (@block_events) {
	push(@cmd, "-e", $event);
	if ($dev_filter) {
	    push(@cmd, "--filter", $dev_filter);
	}
    }
    push(@cmd, "--");

    # Make sched events cmdline
    push(@cmd, "perf", "record", "-a", "-c1", "-g", "-o", $perf_sched_data);
    foreach my $event (@sched_events) {
	push(@cmd, "-e", $event);
    }
    push(@cmd, "--");

    # Add user cmdline
    push(@cmd, @ARGV);

    safe_system(@cmd);
}

sub cmd_record
{
    my (@opt_device, $help);

    my $ret = GetOptions(
			 "device=s"	=> \@opt_device,
			 "help"		=> \$help,
			);

    record_help() if ($help || !$ret);

    my $dev_filter = make_filter_str(@opt_device);
    run_record($dev_filter);
}

sub report_help
{
    print <<"EOF";
Usage: $0 report <options>

Options:
 -p, --pid=PID                Output Schedule time for PIDs.
                              Accepts multiple times (e.g. -p 1 -p 2 -p 3)
 -s, --seek-threshold=VAL     Seek threshold. If seek distance is smaller than
                              VAL, this seek is ignored.
 -r, --relative-seek          Calculate seek relative distance. I.e. if next
                              access is before last access, use start of last
                              access. Otherwise, use end of last access.
 -h, --help                   This help.

EOF

    exit(1);
}

sub cmd_report
{
    my (@opt_pid, $help);

    my $ret = GetOptions(
			 "pid=i"		=> \@opt_pid,
			 "seek-threshold=i"	=> \$seek_threshold,
			 "relative-seek"	=> \$seek_relative,
			 "help"			=> \$help,
			);

    report_help() if ($help || !$ret);

    # Pass parameters as environment variables
    $ENV{FSPERF_MODE} = "FSPERF_MODE_REPORT";
    $ENV{FSPERF_SCRIPT} = $0;
    $ENV{FSPERF_TARGET_PID} = join(',',@opt_pid);
    $ENV{FSPERF_SEEK_THRESHOLD} = $seek_threshold;
    $ENV{FSPERF_SEEK_RELATIVE} = $seek_relative;

    run_next_cmd();
}

sub cmd_help
{
    print <<"EOF";
Usage: $0 [record|report|help] <options> -- <cmdline>

    record           Records performance data
    report           Make report from result of recorded data
    help             This help

EOF

    exit(1);
}

my %cmd_func = (
		"record"	=> \&cmd_record,
		"report"	=> \&cmd_report,
		"help"		=> \&cmd_help,
	       );

# Called from perf script?
unless ($ENV{'PERF_EXEC_PATH'}) {
    my $cmd = shift(@ARGV);
    if ($cmd and $cmd_func{$cmd}) {
	$cmd_func{$cmd}(@ARGV);
    } else {
	cmd_help(@ARGV);
    }
}
